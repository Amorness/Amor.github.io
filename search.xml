<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[队列&栈 之 练习题]]></title>
    <url>%2F2019%2F12%2F03%2Fleetcodestudy2%2F</url>
    <content type="text"><![CDATA[小白的LeetCode探索之路2：队列&amp;栈本章主要对一些经典的队列与栈的算法题进行练习,包括：岛屿数量、打开转盘锁、完全平方数、有效的括号、每日温度、逆波兰表达式求值、目标和、二叉树的中序遍历。 岛屿数量描述： 给定一个由 &#39;1&#39;（陆地）和 &#39;0&#39;（水）组成的的二维网格，计算岛屿的数量。一个岛被水包围，并且它是通过水平方向或垂直方向上相邻的陆地连接而成的。你可以假设网格的四个边均被水包围。 示例1： 1234567输入:11110110101100000000输出: 1 示例2： 1234567输入:11000110000010000011输出: 3 解决思路： 类似于一个感染的问题，我们首先遍历整个二维数组，当遇到’1’的时候，将它连接着的所有’1’都变成某个数，并且岛屿个数增加1。 Java版： 1234567891011121314151617181920212223242526272829303132333435363738class Solution &#123; public void setOne(char[][] grid,int row,int col)&#123; int m = grid.length; int n = grid[0].length; if((row&lt;0)||(row&gt;=m)||(col&lt;0)||(col&gt;=n)||(grid[row][col]!='1'))&#123; return; &#125; grid[row][col] = 2; setOne(grid,row-1,col); setOne(grid,row+1,col); setOne(grid,row,col-1); setOne(grid,row,col+1); &#125; public int numIslands(char[][] grid)&#123; int sum = 0; if (grid.length == 0)&#123; return 0; &#125; if (grid[0].length == 0)&#123; return 0; &#125; //获取行列数必须在判断行列是否为0之后，否则会导致数组下标越界 int m = grid.length; int n = grid[0].length; for (int i=0;i&lt;m;i++)&#123; for (int j=0;j&lt;n;j++)&#123; if (grid[i][j]=='1')&#123; sum++; setOne(grid,i,j); &#125; &#125; &#125; return sum; &#125;&#125; 打开转盘锁描述： 你有一个带有四个圆形拨轮的转盘锁。每个拨轮都有10个数字： &#39;0&#39;, &#39;1&#39;, &#39;2&#39;, &#39;3&#39;, &#39;4&#39;, &#39;5&#39;, &#39;6&#39;, &#39;7&#39;, &#39;8&#39;, &#39;9&#39; 。每个拨轮可以自由旋转：例如把 &#39;9&#39; 变为 &#39;0&#39;，&#39;0&#39; 变为 &#39;9&#39; 。每次旋转都只能旋转一个拨轮的一位数字。 锁的初始数字为 &#39;0000&#39; ，一个代表四个拨轮的数字的字符串。 列表 deadends 包含了一组死亡数字，一旦拨轮的数字和列表里的任何一个元素相同，这个锁将会被永久锁定，无法再被旋转。 字符串 target 代表可以解锁的数字，你需要给出最小的旋转次数，如果无论如何不能解锁，返回 -1。 示例1： 123456输入：deadends = ["0201","0101","0102","1212","2002"], target = "0202"输出：6解释：可能的移动序列为 "0000" -&gt; "1000" -&gt; "1100" -&gt; "1200" -&gt; "1201" -&gt; "1202" -&gt; "0202"。注意 "0000" -&gt; "0001" -&gt; "0002" -&gt; "0102" -&gt; "0202" 这样的序列是不能解锁的，因为当拨动到 "0102" 时这个锁就会被锁定。 示例2： 1234输入: deadends = ["8888"], target = "0009"输出：1解释：把最后一位反向旋转一次即可 "0000" -&gt; "0009"。 示例3： 1234输入: deadends = ["8887","8889","8878","8898","8788","8988","7888","9888"], target = "8888"输出：-1解释：无法旋转到目标数字且不被锁定。 示例4： 12输入: deadends = ["0000"], target = "8888"输出：-1 提示： 死亡列表 deadends 的长度范围为 [1, 500]。 目标数字 target 不会在 deadends 之中。 每个 deadends 和 target 中的字符串的数字会在 10,000 个可能的情况 &#39;0000&#39; 到 &#39;9999&#39; 中产生。 解决思路： 图搜索+广度优先搜索。 对于这个问题，密码锁的每一个状态都对应着图上的一个顶点。比如状态”0000”是一个顶点，”0001”是另一个顶点。如果转动某个转轮一次可以让密码锁从一个状态转移到另一个状态，那么这两个状态之间有一条边相连。例如在状态”0000”分别向上或者向下转动四个转轮中的一个，可以得到如下8个状态：”0001”、”0009”、”0010”、”0090”、”0100”、”0900”、”1000”和”9000”。那么图中顶点”0000”就有8条边分别和这8个状态对应的顶点相连。 由于题目要求的是找出顶点”0000”到目标状态对应的顶点的最短路径，那么我们应该采用广度优先搜索算法。这是因为广度优先搜索是从源点开始首先达到所有距离源点为1的顶点，接着轮到达所有距离源点为2的所有顶点。根据广度优先搜索从源点到达某一顶点，那么一定是途径从源点到达该结点的最短路径。 同时，我们可以从源点开始单项搜索；也可以既从源点出发，又从目标点出发双向搜索。 单向java版： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556public class openLock &#123; private List&lt;String&gt; getNexts(String cur) &#123; List&lt;String&gt; nexts = new LinkedList&lt;&gt;(); for (int i = 0; i &lt; cur.length(); ++i) &#123; char ch = cur.charAt(i); char newCh = ch == '0' ? '9' : (char)(ch - 1); StringBuilder builder = new StringBuilder(cur); builder.setCharAt(i, newCh); nexts.add(builder.toString()); newCh = ch == '9' ? '0' : (char)(ch + 1); builder = new StringBuilder(cur); builder.setCharAt(i, newCh); nexts.add(builder.toString()); &#125; return nexts; &#125; public int openLock(String[] deadends, String target) &#123; Set&lt;String&gt; dead = new HashSet&lt;&gt;(Arrays.asList(deadends)); Set&lt;String&gt; visited = new HashSet&lt;&gt;(); String init = "0000"; if (dead.contains(init) || dead.contains(target)) &#123; return -1; &#125; Queue&lt;String&gt; queue1 = new LinkedList&lt;&gt;(); Queue&lt;String&gt; queue2 = new LinkedList&lt;&gt;(); int steps = 0; queue1.offer(init); while (!queue1.isEmpty()) &#123; String cur = queue1.poll(); if (cur.equals(target)) &#123; return steps; &#125; List&lt;String&gt; nexts = getNexts(cur); for (String next : nexts) &#123; if (!dead.contains(next) &amp;&amp; !visited.contains(next)) &#123; visited.add(next); queue2.offer(next); &#125; &#125; if (queue1.isEmpty()) &#123; steps++; queue1 = queue2; queue2 = new LinkedList&lt;&gt;(); &#125; &#125; return -1; &#125; 双向Java版： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566public class openLock &#123; private List&lt;String&gt; getNexts(String cur) &#123; List&lt;String&gt; nexts = new LinkedList&lt;&gt;(); for (int i = 0; i &lt; cur.length(); ++i) &#123; char ch = cur.charAt(i); char newCh = ch == '0' ? '9' : (char)(ch - 1); StringBuilder builder = new StringBuilder(cur); builder.setCharAt(i, newCh); nexts.add(builder.toString()); newCh = ch == '9' ? '0' : (char)(ch + 1); builder = new StringBuilder(cur); builder.setCharAt(i, newCh); nexts.add(builder.toString()); &#125; return nexts; &#125; public int openLock(String[] deadends, String target) &#123; Set&lt;String&gt; dead = new HashSet&lt;&gt;(Arrays.asList(deadends)); Set&lt;String&gt; visited = new HashSet&lt;&gt;(); String init = "0000"; if (dead.contains(init) || dead.contains(target)) &#123; return -1; &#125; if (target.equals(init)) &#123; return 0; &#125; Set&lt;String&gt; set1 = new HashSet&lt;&gt;(); set1.add(init); Set&lt;String&gt; set2 = new HashSet&lt;&gt;(); set2.add(target); int steps = 0; while (!set1.isEmpty() &amp;&amp; !set2.isEmpty()) &#123; if (set1.size() &gt; set2.size()) &#123; Set&lt;String&gt; temp = set1; set1 = set2; set2 = temp; &#125; Set&lt;String&gt; set3 = new HashSet&lt;&gt;(); for (String cur : set1) &#123; for (String next : getNexts(cur)) &#123; if (set2.contains(next)) &#123; return steps + 1; &#125; if (!dead.contains(next) &amp;&amp; !visited.contains(next)) &#123; visited.add(next); set3.add(next); &#125; &#125; &#125; steps++; set1 = set3; &#125; return -1; &#125; 完全平方数描述： 给定正整数 n，找到若干个完全平方数（比如 1, 4, 9, 16, ...）使得它们的和等于 n。你需要让组成和的完全平方数的个数最少。 示例1： 123输入: n = 12输出: 3 解释: 12 = 4 + 4 + 4. 示例2： 123输入: n = 13输出: 2解释: 13 = 4 + 9. 解题思路： 易知f(1)=1;f(2)=2;f(3)=3;当n=某一个数的平方时，易知f(n)=1; 当n=6时，f(6)的情况有2种——分别是f(1)+f(6-1)和f(4)+f(6-4),即f(1)+f(5)和f(4)+f(2)。那么f(6)的值便是这两者的最小值，即min( f(1)+f(5) , f(4)+f(2) );情况1：f(1)的值=1，那f(5)的值等于多少呢？我们可以继续往下推：f(5)的情况有2种：f(1)+f(4)和f(4)+f(1);情况1.1：f(1)=1,f(4)=1;那么f(5)=2；情况1.2：f(5)=2;最终f(5)的值为情况1.1和1.2中的最小值，即f(5)=2;那么情况1的结构便是f(6)=3;同理可计算出情况2的结果； 以此类推。。。 12345678910111213class Solution &#123; public int numSquares(int n) &#123; int[] arr = new int[n+1];//依然是设置数组来保存计算出的值 arr[1] = 1; //f(1)当然是1了 for(int i=2;i&lt;n+1;i++)&#123;//自底向上，依次计算出f(n)的值，并保存在arr[n]中 int min = Integer.MAX_VALUE; for(int j=1;j*j &lt;= i;j++) min = Math.min( min,arr[i-j*j]); arr[i] = min + 1; &#125; return arr[n]; &#125;&#125; 有效的括号描述： 给定一个只包括 &#39;(&#39;，&#39;)&#39;，&#39;{&#39;，&#39;}&#39;，&#39;[&#39;，&#39;]&#39; 的字符串，判断字符串是否有效。 有效字符串需满足： 左括号必须用相同类型的右括号闭合。 左括号必须以正确的顺序闭合。 注意空字符串可被认为是有效字符串 示例1： 12输入: "()"输出: true 示例2： 12输入: "()[]&#123;&#125;"输出: true 示例3： 12输入: "(]"输出: false 示例4： 12输入: "([)]"输出: false 示例5： 12输入: "&#123;[]&#125;"输出: true 解题思路： 整体思路比较简单，利用栈先进后出的性质就可以很好地解决。首先初始化一个栈，如果是 ‘[‘ 或者 ‘{‘ 或者’（’，就推入堆栈。如果是 ‘]’ 或者 ‘}’或者 ‘）’，就把堆栈顶上的元素pop出来，看看有没有匹配的。如果没有匹配的，直接返回False，最后判断栈是否为空，如果为空，就返回True。 java版： 123456789101112131415161718192021222324252627282930313233class Solution &#123; public boolean isValid(String s) &#123; Stack&lt;Character&gt; stack1 = new Stack&lt;&gt;(); for (int i = 0; i &lt; s.length(); i++) &#123; char ch = s.charAt(i); if (ch =='[' || ch == '&#123;' || ch == '(') &#123; stack1.push(ch); &#125; else &#123; if (stack1.isEmpty()) &#123; return false; &#125; char topch = stack1.pop(); if (ch == ']' &amp;&amp; topch!='[' ) &#123; return false; &#125; else if (ch == '&#125;' &amp;&amp; topch!='&#123;') &#123; return false; &#125;else if (ch == ')' &amp;&amp; topch!='(') &#123; return false; &#125; &#125; &#125; return stack1.isEmpty(); &#125;&#125; 每日温度描述： 根据每日 气温 列表，请重新生成一个列表，对应位置的输入是你需要再等待多久温度才会升高超过该日的天数。如果之后都不会升高，请在该位置用 0 来代替。 例如，给定一个列表 temperatures = [73, 74, 75, 71, 69, 72, 76, 73]，你的输出应该是 [1, 1, 4, 2, 1, 1, 0, 0]。 提示：气温 列表长度的范围是 [1, 30000]。每个气温的值的均为华氏度，都是在 [30, 100] 范围内的整数。 解题思路： 本人首先想到了用栈来解决这个问题。放入栈中的元素为温度数组的下标。 首先第一个元素73的下标入栈，[0]； 然后遍历数组，第二个元素74与栈顶元素比较大小，大于栈顶元素，栈顶元素出栈，74的下标入栈，[1]；数组第一个元素对应的输出就是74的下标-栈顶元素，即1-0=1； 同理，75&gt;74，栈顶元素出栈，75的下标入栈，74的输出为75的下标-栈顶元素，即2-1=1； 由于71&lt;75，下标直接入栈，[2,3]； 同理69&lt;71，下标直接入栈，[2,3,4]； 循环：72&gt;69，69的下标出栈，69对应的输出5-4=1,[2,3];72&gt;71，71的下标出栈，71对应的输出5-3=2；。。。 最后，如果栈不为空，那么剩余元素对应的输出都是0。 Java版： 12345678910111213141516171819202122232425class Solution &#123; public int[] dailyTemperatures(int[] T) &#123; Stack&lt;Integer&gt; stack1 = new Stack&lt;&gt;(); int[] output = new int[T.length]; for(int i = 0;i&lt;T.length;i++)&#123; if (i==0)&#123; stack1.push(i); continue; &#125; while (T[i] &gt; T[stack1.peek()])&#123; output[stack1.peek()] = i - stack1.peek(); stack1.pop(); if (stack1.isEmpty())&#123;break;&#125; &#125; stack1.push(i); &#125; if (!stack1.isEmpty())&#123; output[stack1.peek()] = 0; stack1.pop(); &#125; return output; &#125;&#125; 还有大佬不用栈，直接对数组进行反向遍历，如下所示： Java版： 123456789101112131415161718192021222324class Solution &#123; public int[] dailyTemperatures(int[] T) &#123; int n = T.length; int []res = new int[n]; for(int i = n - 2; i &gt;= 0; i--) &#123; for(int j = i + 1; j &lt; n; j += res[j]) &#123; if(T[i] &lt; T[j]) &#123; res[i] = j - i; break; &#125; else if(res[j] == 0) &#123; res[i] = 0; break; &#125; &#125; &#125; return res; &#125;&#125; 逆波兰表达式求值描述： 根据逆波兰表示法，求表达式的值。 有效的运算符包括 +, -, *, / 。每个运算对象可以是整数，也可以是另一个逆波兰表达式。 说明： 整数除法只保留整数部分。 给定逆波兰表达式总是有效的。换句话说，表达式总会得出有效数值且不存在除数为 0 的情况。 示例1： 123输入: ["2", "1", "+", "3", "*"]输出: 9解释: ((2 + 1) * 3) = 9 示例2： 123输入: ["4", "13", "5", "/", "+"]输出: 6解释: (4 + (13 / 5)) = 6 示例3： 12345678910输入: ["10", "6", "9", "3", "+", "-11", "*", "/", "*", "17", "+", "5", "+"]输出: 22解释: ((10 * (6 / ((9 + 3) * -11))) + 17) + 5= ((10 * (6 / (12 * -11))) + 17) + 5= ((10 * (6 / -132)) + 17) + 5= ((10 * 0) + 17) + 5= (0 + 17) + 5= 17 + 5= 22 解题思路： 栈的典型应用，碰到数字就入栈，碰到运算符就取栈最上面的两个数字，然后将运算结果再入栈。 Java版： 123456789101112131415161718192021222324252627282930class Solution &#123; public int evalRPN(String[] tokens) &#123; Stack&lt;Integer&gt; stack=new Stack&lt;Integer&gt;(); int num1=0,num2=0; for (int i = 0; i &lt; tokens.length; i++) &#123; String s=tokens[i]; if(s.equals("+"))&#123; num1=stack.pop(); num2=stack.pop(); stack.push(num2+num1); &#125;else if(s.equals("-"))&#123; num1=stack.pop(); num2=stack.pop(); stack.push(num2-num1); &#125;else if(s.equals("*"))&#123; num1=stack.pop(); num2=stack.pop(); stack.push(num2*num1); &#125;else if(s.equals("/"))&#123; num1=stack.pop(); num2=stack.pop(); stack.push(num2/num1); &#125;else&#123; stack.push(Integer.parseInt(s)); &#125; &#125; return stack.pop(); &#125;&#125; 目标和描述： 给定一个非负整数数组，a1, a2, …, an, 和一个目标数，S。现在你有两个符号 + 和 -。对于数组中的任意一个整数，你都可以从 + 或 -中选择一个符号添加在前面。 返回可以使最终数组和为目标数 S 的所有添加符号的方法数。 示例1： 1234567891011输入: nums: [1, 1, 1, 1, 1], S: 3输出: 5解释: -1+1+1+1+1 = 3+1-1+1+1+1 = 3+1+1-1+1+1 = 3+1+1+1-1+1 = 3+1+1+1+1-1 = 3一共有5种方法让最终目标和为3。 注意: 数组非空，且长度不会超过20。 初始的数组的和不会超过1000。 保证返回的最终结果能被32位整数存下。 解题思路： 该问题可以理解成，将数组分割成两个子集sum(P)和sum(N)，其中sum(P)全为正数，sum(N)全为负数。 即：sum(P)-sum(N)=S；sum(P)+sum(N)=sum(sums)； 两式相加：2sum(P) = S+sum(sums)； 即：sum(P) = (S+sum(sums))/2； 因此可以转换目标值，将原题转换为求正数子集，且该子集元素之和为(S+sum(sums))/2，动态规划问题； 举例说明： 给定集合nums={1,2,3,4,5}, 求解子集，使子集中元素之和等于9 = new_target = sum(P) = (target+sum(nums))/2 定义dp[10]数组, dp[10] = {1,0,0,0,0,0,0,0,0,0}，由于是非负整数子集，因此为0只有一种可能，空集合; dp[i]表示子集合元素之和等于当前目标值的方案个数, 当前目标值等于9减去当前元素值 ​ 当前元素等于1时，dp[9] = dp[9] + dp[9-1] ​ dp[8] = dp[8] + dp[8-1] ​ … ​ dp[1] = dp[1] + dp[1-1] ​ 当前元素等于2时，dp[9] = dp[9] + dp[9-2] ​ dp[8] = dp[8] + dp[8-2] ​ … ​ dp[2] = dp[2] + dp[2-2] ​ 当前元素等于3时，dp[9] = dp[9] + dp[9-3] ​ dp[8] = dp[8] + dp[8-3] ​ … ​ dp[3] = dp[3] + dp[3-3] ​ 当前元素等于4时， ​ … ​ 当前元素等于5时， ​ … ​ dp[5] = dp[5] + dp[5-5] ​ 最后返回dp[9]即是所求的解 Java版： 12345678910111213141516171819class Solution &#123; public int findTargetSumWays(int[] nums, int S) &#123; int sum = 0; for (int i = 0; i &lt; nums.length; i++) &#123; sum += nums[i]; &#125; if (S &gt; sum || (sum + S) % 2 == 1) return 0; int target = (sum + S) / 2; int[] dp = new int[target + 1]; dp[0] = 1;//C(0,0)=1 for (int i = 0; i &lt; nums.length; i++) &#123; for (int j = target; j &gt;= nums[i]; j--) &#123; dp[j] += dp[j - nums[i]]; &#125; &#125; return dp[target]; &#125;&#125; 二叉树的中序遍历描述： 给定一个二叉树，返回它的中序 遍历。 示例： 12345678输入: [1,null,2,3] 1 \ 2 / 3输出: [1,3,2] 进阶: 递归算法很简单，通过迭代算法完成。 解题思路1： 递归。 Java版： 123456789101112131415161718192021222324class Solution &#123; public void inorder(TreeNode root, List&lt;Integer&gt; res) &#123; if(root.left!=null) &#123; inorder(root.left, res); &#125; res.add(root.val); if(root.right!=null) &#123; inorder(root.right, res); &#125; &#125; public List&lt;Integer&gt; inorderTraversal(TreeNode root) &#123; List&lt;Integer&gt; res=new ArrayList&lt;&gt;(); if(root==null) &#123; return res; &#125; inorder(root, res); return res; &#125;&#125; 解题思路2： 使用栈，首先将root节点放进栈，并将root节点的左子节点更新为新的根节点，对左子树进行遍历，以此类推。 Java版： 12345678910111213141516171819202122232425262728/** * Definition for a binary tree node. * public class TreeNode &#123; * int val; * TreeNode left; * TreeNode right; * TreeNode(int x) &#123; val = x; &#125; * &#125; */class Solution &#123; public List&lt;Integer&gt; inorderTraversal(TreeNode root) &#123; Stack&lt;TreeNode&gt; stack = new Stack&lt;&gt;(); List&lt;Integer&gt; list = new ArrayList&lt;&gt;(); while (root != null || !stack.isEmpty()) &#123; if (root != null) &#123; stack.push(root); root = root.left; &#125; else &#123; root = stack.pop(); list.add(root.val); root = root.right; &#125; &#125; return list; &#125;&#125; 结束语： 身为复旦的一名研究生，在北京竟然待了快半年，日了狗了。。]]></content>
      <categories>
        <category>数据结构</category>
        <category>队列&amp;栈</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
        <tag>队列</tag>
        <tag>栈</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据结构：队列&栈]]></title>
    <url>%2F2019%2F08%2F12%2Fleetcodestudy1%2F</url>
    <content type="text"><![CDATA[小白的LeetCode探索之路：队列&amp;栈鉴于暑期被实验室发配帝都实习两个月，在公司摸鱼的时候感到自己明年就要准备面试，于是乎准备刷LeetCode。但是鉴于本身算法基础不是很扎实，所以打算先对一些基础的数据结构进行一些复习。 队列 队列是一种FIFO（先入先出）的数据结构，在 FIFO 数据结构中，将首先处理添加到队列中的第一个元素。 如上图所示，插入（insert）操作也称作入队（enqueue），新元素始终被添加在队列的末尾。 删除（delete）操作也被称为出队（dequeue)。 你只能移除第一个元素。 队列-实现为了实现队列，我们可以使用动态数组和指向队列头部的索引。 如上所述，队列应支持两种操作：入队和出队。入队会向队列追加一个新元素，而出队会删除第一个元素。 所以我们需要一个索引来指出起点。 java版： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152// "static void main" must be defined in a public class.class MyQueue &#123; // store elements private List&lt;Integer&gt; data; // a pointer to indicate the start position private int p_start; public MyQueue() &#123; data = new ArrayList&lt;Integer&gt;(); p_start = 0; &#125; /** Insert an element into the queue. Return true if the operation is successful. */ public boolean enQueue(int x) &#123; data.add(x); return true; &#125;; /** Delete an element from the queue. Return true if the operation is successful. */ public boolean deQueue() &#123; if (isEmpty() == true) &#123; return false; &#125; p_start++; return true; &#125; /** Get the front item from the queue. */ public int Front() &#123; return data.get(p_start); &#125; /** Checks whether the queue is empty or not. */ public boolean isEmpty() &#123; return p_start &gt;= data.size(); &#125; &#125;;public class Main &#123; public static void main(String[] args) &#123; MyQueue q = new MyQueue(); q.enQueue(5); q.enQueue(3); if (q.isEmpty() == false) &#123; System.out.println(q.Front()); &#125; q.deQueue(); if (q.isEmpty() == false) &#123; System.out.println(q.Front()); &#125; q.deQueue(); if (q.isEmpty() == false) &#123; System.out.println(q.Front()); &#125; &#125;&#125; C++版： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849#include &lt;iostream&gt;class MyQueue &#123; private: // store elements vector&lt;int&gt; data; // a pointer to indicate the start position int p_start; public: MyQueue() &#123;p_start = 0;&#125; /** Insert an element into the queue. Return true if the operation is successful. */ bool enQueue(int x) &#123; data.push_back(x); return true; &#125; /** Delete an element from the queue. Return true if the operation is successful. */ bool deQueue() &#123; if (isEmpty()) &#123; return false; &#125; p_start++; return true; &#125;; /** Get the front item from the queue. */ int Front() &#123; return data[p_start]; &#125;; /** Checks whether the queue is empty or not. */ bool isEmpty() &#123; return p_start &gt;= data.size(); &#125;&#125;;int main() &#123; MyQueue q; q.enQueue(5); q.enQueue(3); if (!q.isEmpty()) &#123; cout &lt;&lt; q.Front() &lt;&lt; endl; &#125; q.deQueue(); if (!q.isEmpty()) &#123; cout &lt;&lt; q.Front() &lt;&lt; endl; &#125; q.deQueue(); if (!q.isEmpty()) &#123; cout &lt;&lt; q.Front() &lt;&lt; endl; &#125;&#125; 缺点通过上面的简单队列的实现，我们可以发现有些时候，随着起始指针的移动，浪费了越来越多的空间。 当我们有空间限制时，这将是难以接受的。 让我们考虑一种情况，即我们只能分配一个最大长度为 5 的数组。当我们只添加少于 5 个元素时，我们的解决方案很有效。 例如，如果我们只调用入队函数四次后还想要将元素 10 入队，那么我们可以成功。 但是我们不能接受更多的入队请求，这是合理的，因为现在队列已经满了。但是如果我们将一个元素出队呢？ 实际上，当我们将队头的元素进行删除之后，按理说这部分空间已经空余，我们完全可以再接受一个新的元素，但是普通的队列并不支持这种操作，因此我们需要循环队列。 循环队列此前，我们提供了一种简单但低效的队列实现。 更有效的方法是使用循环队列。 具体来说，我们可以使用固定大小的数组和两个指针来指示起始位置和结束位置。 目的是重用我们之前提到的被浪费的存储。 我们通过一系列简单的操作，来模拟一下循环队列的原理： 循环队列-实现在循环队列中，我们使用一个数组和两个指针（head 和 tail）。 head 表示队列的起始位置，tail 表示队列的结束位置。 Java版： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879class MyCircularQueue &#123; private int[] data; private int head; private int tail; private int size; /** Initialize your data structure here. Set the size of the queue to be k. */ public MyCircularQueue(int k) &#123; data = new int[k]; head = -1; tail = -1; size = k; &#125; /** Insert an element into the circular queue. Return true if the operation is successful. */ public boolean enQueue(int value) &#123; if (isFull() == true) &#123; return false; &#125; if (isEmpty() == true) &#123; head = 0; &#125; tail = (tail + 1) % size; data[tail] = value; return true; &#125; /** Delete an element from the circular queue. Return true if the operation is successful. */ public boolean deQueue() &#123; if (isEmpty() == true) &#123; return false; &#125; if (head == tail) &#123; head = -1; tail = -1; return true; &#125; head = (head + 1) % size; return true; &#125; /** Get the front item from the queue. */ public int Front() &#123; if (isEmpty() == true) &#123; return -1; &#125; return data[head]; &#125; /** Get the last item from the queue. */ public int Rear() &#123; if (isEmpty() == true) &#123; return -1; &#125; return data[tail]; &#125; /** Checks whether the circular queue is empty or not. */ public boolean isEmpty() &#123; return head == -1; &#125; /** Checks whether the circular queue is full or not. */ public boolean isFull() &#123; return ((tail + 1) % size) == head; &#125;&#125;/** * Your MyCircularQueue object will be instantiated and called as such: * MyCircularQueue obj = new MyCircularQueue(k); * boolean param_1 = obj.enQueue(value); * boolean param_2 = obj.deQueue(); * int param_3 = obj.Front(); * int param_4 = obj.Rear(); * boolean param_5 = obj.isEmpty(); * boolean param_6 = obj.isFull(); */ C++版： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879class MyCircularQueue &#123;private: vector&lt;int&gt; data; int head; int tail; int size;public: /** Initialize your data structure here. Set the size of the queue to be k. */ MyCircularQueue(int k) &#123; data.resize(k); head = -1; tail = -1; size = k; &#125; /** Insert an element into the circular queue. Return true if the operation is successful. */ bool enQueue(int value) &#123; if (isFull()) &#123; return false; &#125; if (isEmpty()) &#123; head = 0; &#125; tail = (tail + 1) % size; data[tail] = value; return true; &#125; /** Delete an element from the circular queue. Return true if the operation is successful. */ bool deQueue() &#123; if (isEmpty()) &#123; return false; &#125; if (head == tail) &#123; head = -1; tail = -1; return true; &#125; head = (head + 1) % size; return true; &#125; /** Get the front item from the queue. */ int Front() &#123; if (isEmpty()) &#123; return -1; &#125; return data[head]; &#125; /** Get the last item from the queue. */ int Rear() &#123; if (isEmpty()) &#123; return -1; &#125; return data[tail]; &#125; /** Checks whether the circular queue is empty or not. */ bool isEmpty() &#123; return head == -1; &#125; /** Checks whether the circular queue is full or not. */ bool isFull() &#123; return ((tail + 1) % size) == head; &#125;&#125;;/** * Your MyCircularQueue object will be instantiated and called as such: * MyCircularQueue obj = new MyCircularQueue(k); * bool param_1 = obj.enQueue(value); * bool param_2 = obj.deQueue(); * int param_3 = obj.Front(); * int param_4 = obj.Rear(); * bool param_5 = obj.isEmpty(); * bool param_6 = obj.isFull(); */ 队列 - 用法大多数流行语言都提供内置的队列库，因此只需要直接调用即可。 如前所述，队列有两个重要的操作，入队 enqueue 和出队 dequeue。 此外，我们应该能够获得队列中的第一个元素，因为应该首先处理它。 下面是使用内置队列库及其常见操作的一些示例： Java版： 1234567891011121314151617181920// "static void main" must be defined in a public class.public class Main &#123; public static void main(String[] args) &#123; // 1. Initialize a queue. Queue&lt;Integer&gt; q = new LinkedList(); // 2. Get the first element - return null if queue is empty. System.out.println("The first element is: " + q.peek()); // 3. Push new element. q.offer(5); q.offer(13); q.offer(8); q.offer(6); // 4. Pop an element. q.poll(); // 5. Get the first element. System.out.println("The first element is: " + q.peek()); // 7. Get the size of the queue. System.out.println("The size is: " + q.size()); &#125;&#125; C++版： 123456789101112131415161718192021222324#include &lt;iostream&gt;int main() &#123; // 1. Initialize a queue. queue&lt;int&gt; q; // 2. Push new element. q.push(5); q.push(13); q.push(8); q.push(6); // 3. Check if queue is empty. if (q.empty()) &#123; cout &lt;&lt; "Queue is empty!" &lt;&lt; endl; return 0; &#125; // 4. Pop an element. q.pop(); // 5. Get the first element. cout &lt;&lt; "The first element is: " &lt;&lt; q.front() &lt;&lt; endl; // 6. Get the last element. cout &lt;&lt; "The last element is: " &lt;&lt; q.back() &lt;&lt; endl; // 7. Get the size of the queue. cout &lt;&lt; "The size is: " &lt;&lt; q.size() &lt;&lt; endl;&#125; 队列-BFS广度优先搜索（BFS）又称宽度优先搜索，一般用来解决最短路径问题。广搜的目标是，一旦找到一条从起点到目标结点的路径，这条路径就一定是最优的(步数最少)的。广搜是按怎样顺序来搜索的呢？我们通过以下一棵树来进行示范。 我们要想广度优先，那么首先搜索第一层1,然后搜索第二层，从左向右2,5,6,9，在搜索第三层，从左向右3,4,7,10，再搜索第四层8，很简单吧，这就是一个层次遍历。 对于BFS程序的实现需要借助队列： (1)首先，令树根1入队 (2)队头元素出队，输出1，同时令1的所有孩子(从左向右顺序)入队 (3)队头元素出队，输出2，同时令2的所有孩子(从左向右顺序)入队 (4)队头元素出队，输出5，同时令5的所有孩子(从左向右顺序)入队，5没有孩子，不操作 (5)队头元素出队，输出6，同时令6的所有孩子(从左向右顺序)入队 (6)队头元素出队，输出9，同时令9的所有孩子(从左向右顺序)入队 (7)队头元素出队，输出3，同时令3的所有孩子(从左向右顺序)入队，3没有孩子，不操作 (8)队头元素出队，输出4，同时令4的所有孩子(从左向右顺序)入队，4没有孩子，不操作 (9)队头元素出队，输出7，同时令7的所有孩子(从左向右顺序)入队 (10)队头元素出队，输出10，同时令10的所有孩子(从左向右顺序)入队，10没有孩子，不操作 (11)队头元素出队，输出8，同时令8的所有孩子(从左向右顺序)入队，8没有孩子，不操作 队列的情况如下所示： （1） 1 （2） 2 5 6 9 （3） 5 6 9 3 4 （4） 6 9 3 4 （5） 9 3 4 7 （6） 3 4 7 10 （7） 4 7 10 （8） 7 10 （9） 10 8 （10） 8 （11） 此时队列为空，结束。输出顺序为1、2、5、6、9、3、4、7、10、8，该顺序即是BFS搜索的顺序，全图遍历。如果找最优解，搜索过程中找到便结束。 结点的处理顺序在第一轮中，我们处理根结点。在第二轮中，我们处理根结点旁边的结点；在第三轮中，我们处理距根结点两步的结点；等等等等。 与树的层序遍历类似，越是接近根结点的结点将越早地遍历。 如果在第 k 轮中将结点 X 添加到队列中，则根结点与 X 之间的最短路径的长度恰好是 k。也就是说，第一次找到目标结点时，你已经处于最短路径中。 队列的入队和出队顺序我们首先将根结点排入队列。然后在每一轮中，我们逐个处理已经在队列中的结点，并将所有邻居添加到队列中。值得注意的是，新添加的节点不会立即遍历，而是在下一轮中处理。 结点的处理顺序与它们添加到队列的顺序是完全相同的顺序，即先进先出（FIFO）。这就是我们在 BFS 中使用队列的原因。 伪代码有时，确保我们永远不会访问一个结点两次很重要。否则，我们可能陷入无限循环。因此，我们可以通过添加一个哈希集来解决这个问题。 1234567891011121314151617181920212223242526272829/** * Return the length of the shortest path between root and target node. */int BFS(Node root, Node target) &#123; Queue&lt;Node&gt; queue; // store all nodes which are waiting to be processed Set&lt;Node&gt; used; // store all the used nodes int step = 0; // number of steps neeeded from root to current node // initialize add root to queue; add root to used; // BFS while (queue is not empty) &#123; step = step + 1; // iterate the nodes which are already in the queue int size = queue.size(); for (int i = 0; i &lt; size; ++i) &#123; Node cur = the first node in queue; return step if cur is target; for (Node next : the neighbors of cur) &#123; if (next is not in used) &#123; add next to queue; add next to used; &#125; &#125; remove the first node from queue; &#125; &#125; return -1; // there is no path from root to target&#125; 有两种情况你不需要使用哈希集： 你完全确定没有循环，例如，在树遍历中； 你确实希望多次将结点添加到队列中。 栈 与队列不同，栈是一个 LIFO 数据结构。在 LIFO 数据结构中，将首先处理添加到队列中的最新元素。 通常，插入操作在栈中被称作入栈 push 。与队列类似，总是在堆栈的末尾添加一个新元素。但是，删除操作，退栈 pop ，将始终删除队列中相对于它的最后一个元素。 栈-实现栈的实现比队列容易。动态数组足以实现堆栈结构。 Java版： 123456789101112131415161718192021222324252627282930313233343536373839404142// "static void main" must be defined in a public class.class MyStack &#123; private List&lt;Integer&gt; data; // store elements public MyStack() &#123; data = new ArrayList&lt;&gt;(); &#125; /** Insert an element into the stack. */ public void push(int x) &#123; data.add(x); &#125; /** Checks whether the queue is empty or not. */ public boolean isEmpty() &#123; return data.isEmpty(); &#125; /** Get the top item from the queue. */ public int top() &#123; return data.get(data.size() - 1); &#125; /** Delete an element from the queue. Return true if the operation is successful. */ public boolean pop() &#123; if (isEmpty()) &#123; return false; &#125; data.remove(data.size() - 1); return true; &#125;&#125;;public class Main &#123; public static void main(String[] args) &#123; MyStack s = new MyStack(); s.push(1); s.push(2); s.push(3); for (int i = 0; i &lt; 4; ++i) &#123; if (!s.isEmpty()) &#123; System.out.println(s.top()); &#125; System.out.println(s.pop()); &#125; &#125;&#125; C++版： 12345678910111213141516171819202122232425262728293031323334353637383940#include &lt;iostream&gt;class MyStack &#123; private: vector&lt;int&gt; data; // store elements public: /** Insert an element into the stack. */ void push(int x) &#123; data.push_back(x); &#125; /** Checks whether the queue is empty or not. */ bool isEmpty() &#123; return data.empty(); &#125; /** Get the top item from the queue. */ int top() &#123; return data.back(); &#125; /** Delete an element from the queue. Return true if the operation is successful. */ bool pop() &#123; if (isEmpty()) &#123; return false; &#125; data.pop_back(); return true; &#125;&#125;;int main() &#123; MyStack s; s.push(1); s.push(2); s.push(3); for (int i = 0; i &lt; 4; ++i) &#123; if (!s.isEmpty()) &#123; cout &lt;&lt; s.top() &lt;&lt; endl; &#125; cout &lt;&lt; (s.pop() ? "true" : "false") &lt;&lt; endl; &#125;&#125; 栈-用法大多数流行的语言都提供了内置的栈库。除了初始化，我们还需要知道如何使用两个最重要的操作：入栈和退栈。除此之外，你应该能够从栈中获得顶部元素。 java版 1234567891011121314151617181920212223// "static void main" must be defined in a public class.public class Main &#123; public static void main(String[] args) &#123; // 1. Initialize a stack. Stack&lt;Integer&gt; s = new Stack&lt;&gt;(); // 2. Push new element. s.push(5); s.push(13); s.push(8); s.push(6); // 3. Check if stack is empty. if (s.empty() == true) &#123; System.out.println("Stack is empty!"); return; &#125; // 4. Pop an element. s.pop(); // 5. Get the top element. System.out.println("The top element is: " + s.peek()); // 6. Get the size of the stack. System.out.println("The size is: " + s.size()); &#125;&#125; C++版 12345678910111213141516171819202122#include &lt;iostream&gt;int main() &#123; // 1. Initialize a stack. stack&lt;int&gt; s; // 2. Push new element. s.push(5); s.push(13); s.push(8); s.push(6); // 3. Check if stack is empty. if (s.empty()) &#123; cout &lt;&lt; "Stack is empty!" &lt;&lt; endl; return 0; &#125; // 4. Pop an element. s.pop(); // 5. Get the top element. cout &lt;&lt; "The top element is: " &lt;&lt; s.top() &lt;&lt; endl; // 6. Get the size of the stack. cout &lt;&lt; "The size is: " &lt;&lt; s.size() &lt;&lt; endl;&#125; 栈-DFS与 BFS 类似，深度优先搜索（DFS）也可用于查找从根结点到目标结点的路径。 节点的处理顺序在上面的例子中，我们从根结点 A 开始。首先，我们选择结点 B 的路径，并进行回溯，直到我们到达结点 E，我们无法更进一步深入。然后我们回溯到 A 并选择第二条路径到结点 C 。从 C 开始，我们尝试第一条路径到 E 但是 E 已被访问过。所以我们回到 C 并尝试从另一条路径到 F。最后，我们找到了 G。 总的来说，在我们到达最深的结点之后，我们只会回溯并尝试另一条路径。 因此，你在 DFS 中找到的第一条路径并不总是最短的路径。例如，在上面的例子中，我们成功找出了路径 A-&gt; C-&gt; F-&gt; G 并停止了 DFS。但这不是从 A 到 G 的最短路径。 栈的入栈和退栈顺序我们首先将根结点推入到栈中；然后我们尝试第一个邻居 B 并将结点 B 推入到栈中；等等等等。当我们到达最深的结点 E 时，我们需要回溯。当我们回溯时，我们将从栈中弹出最深的结点，这实际上是推入到栈中的最后一个结点。 结点的处理顺序是完全相反的顺序，就像它们被添加到栈中一样，它是后进先出（LIFO）。这就是我们在 DFS 中使用栈的原因。 伪代码递归 12345678910111213/* * Return true if there is a path from cur to target. */boolean DFS(Node cur, Node target, Set&lt;Node&gt; visited) &#123; return true if cur is target; for (next : each neighbor of cur) &#123; if (next is not in visited) &#123; add next to visted; return true if DFS(next, target, visited) == true; &#125; &#125; return false;&#125; 显式栈 1234567891011121314151617181920/* * Return true if there is a path from cur to target. */boolean DFS(int root, int target) &#123; Set&lt;Node&gt; visited; Stack&lt;Node&gt; s; add root to s; while (s is not empty) &#123; Node cur = the top element in s; return true if cur is target; for (Node next : the neighbors of cur) &#123; if (next is not in visited) &#123; add next to s; add next to visited; &#125; &#125; remove cur from s; &#125; return false;&#125; 示例: 让我们看一个例子。我们希望在下图中找到结点 0 和结点 3 之间的路径。我们还会在每次调用期间显示栈的状态。 在每个堆栈元素中，都有一个整数 cur，一个整数 target，一个对访问过的数组的引用和一个对数组边界的引用，这些正是我们在 DFS 函数中的参数。我们只在上面的栈中显示 cur。 每个元素都需要固定的空间。栈的大小正好是 DFS 的深度。因此，在最坏的情况下，维护系统栈需要 O(h)，其中 h 是 DFS 的最大深度。在计算空间复杂度时，永远不要忘记考虑系统栈。 参考：力扣： https://leetcode-cn.com/explore/learn/card/queue-stack/218/stack-last-in-first-out-data-structure/876/]]></content>
      <categories>
        <category>数据结构</category>
        <category>队列&amp;栈</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
        <tag>队列</tag>
        <tag>栈</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[机器学习之特征工程]]></title>
    <url>%2F2019%2F04%2F04%2Ffeature%2F</url>
    <content type="text"><![CDATA[机器学习之特征工程坊间常说：“数据和特征决定了机器学习的上限，而模型和算法只是逼近这个上限而已”。由此可见，特征工程在机器学习中占有相当重要的地位。在实际应用当中，可以说特征工程是机器学习成功的关键。在实际应用当中，可以说特征工程是机器学习成功的关键。纵观Kaggle、KDD等国内外大大小小的比赛，每个竞赛的冠军其实并没有用到很高深的算法，大多数都是在特征工程这个环节做出了出色的工作，然后使用一些常见的算法，比如LR，就能得到出色的性能。遗憾的是，在很多的书籍中并没有直接提到特征工程，更多的是特征选择。 本文主要通过以下三个问题出发来理解特征工程： 特征工程是什么？ 为什么要做特征工程？ 应该如何做特征工程？ 特征工程是什么？当你想要你的预测模型性能达到最佳时，你要做的不仅是要选取最好的算法，还要尽可能的从原始数据中获取更多的信息。那么问题来了，你应该如何为你的预测模型得到更好的数据呢？ 想必到了这里你也应该猜到了，是的，这就是特征工程要做的事，它的目的就是获取更好的训练数据。 那么，到底什么是特征工程？我们知道，数据是信息的载体，但是原始的数据包含了大量的噪声，信息的表达也不够简练。特征工程是利用数据领域的相关知识来创建能够使机器学习算法达到最佳性能的特征的过程。使用特征表示的信息，信息损失较少，原始数据中包含的规律依然保留。此外，特征还需要尽量减少原始数据中的不确定因素（白噪声、异常数据、数据缺失…等等）的影响。 下面是前人总结的关于特征工程的思维导图： 特征工程的重要性为什么在实际工作中都要有特征工程这个过程，下面不同的角度来分析一下。 首先，我们大家都知道，数据特征的选择会直接影响我们模型的预测性能。你可以这么说：“选择的特征越好，最终得到的性能也就越好”。这句话说得没错，但也会给我们造成误解。事实上，你得到的实验结果取决于你选择的模型、获取的数据以及使用的特征，甚至你问题的形式和你用来评估精度的客观方法也扮演了一部分。此外，你的实验结果还受到许多相互依赖的属性的影响，你需要的是能够很好地描述你数据内部结构的好特征。 （1）特征越好，灵活性越强 只要特征选得好，即使是一般的模型（或算法）也能获得很好的性能，因为大多数模型（或算法）在好的数据特征下表现的性能都还不错。好特征的灵活性在于它允许你选择不复杂的模型，同时运行速度也更快，也更容易理解和维护。 （2）特征越好，构建的模型越简单 有了好的特征，即便你的参数不是最优的，你的模型性能也能仍然会表现的很nice，所以你就不需要花太多的时间去寻找最有参数，这大大的降低了模型的复杂度，使模型趋于简单。 （3）特征越好，模型的性能越出色 显然，这一点是毫无争议的，我们进行特征工程的最终目的就是提升模型的性能。 特征工程三个子问题特征构建 特征构建是指从原始数据中人工的找出一些具有物理意义的特征。需要花时间去观察原始数据，思考问题的潜在形式和数据结构，对数据敏感性和机器学习实战经验能帮助特征构建。除此之外，属性分割和结合是特征构建时常使用的方法。 下面我们结合具体场景做一些简单介绍： 时间戳处理时间戳属性通常需要分离成多个维度比如年、月、日、小时、分钟、秒钟。通常时间序列数据会含有一定的趋势和周期性，这时需要我们去构建趋势因子和周期因子。 分解类别属性一些属性是类别型而不是数值型，举一个简单的例子，由{红，绿、蓝}组成的颜色属性，最常用的方式是把每个类别属性转换成二元属性，即从{0,1}取一个值。因此基本上增加的属性等于相应数目的类别，并且对于你数据集中的每个实例，只有一个是1（其他的为0），这也就是独热（one-hot)编码方式。当然这个方法并不是唯一的。 分箱和分区有时候，将数值型属性转换成类别呈现更有意义，同时能使算法减少噪声的干扰，通过将一定范围内的数值划分成确定的块。举个例子，我们预测一个人是否拥有某款衣服，这里年龄是一个确切的因子。其实年龄组是更为相关的因子，所以我们可以将年龄分布划分成1-10,11-18,19-25,26-40等年龄段，分别表示 幼儿，青少年，青年，中年四个年龄组，让相近的年龄组表现出相似的属性。此外，我们还可以对分箱，分区做一些统计量字段作为数据的特征。 只有在了解属性的领域知识的基础，确定属性能够划分成简洁的范围时分区才有意义。即所有的数值落入一个分区时能够呈现出共同的特征。在实际应用中，当你不想让你的模型总是尝试区分值之间是否太近时，分区能够避免出现过拟合。例如，如果你所感兴趣的是将一个城市作为整体，这时你可以将所有落入该城市的维度值进行整合成一个整体。分箱也能减小小错误的影响，通过将一个给定值划入到最近的块中。如果划分范围的数量和所有可能值相近，或对你来说准确率很重要的话，此时分箱就不适合了。 交叉特征交叉特征是特征工程中重要的方法之一，交叉特征是一种很独特的方式，它将两个或更多的类别属性组合成一个。当组合的特征要比单个特征更好时，这是一项非常有用的技术。数学上来说，是对类别特征的所有可能值进行交叉相乘。当然我们不仅仅会去查找交叉项关系，还可以去寻找更加复杂的二次项，三次项乃至更复杂的关系，这根据问题求解的需要决定。 经度与纬度的组合便是交叉特征的应用实例，一个相同的经度对应了地图上很多的地方，纬度也是一样。但是一旦你将经度和纬度组合到一起，它们就代表了地理上特定的一块区域，区域中每一部分是拥有着类似的特性 特征提取原始数据常常是高维的，其中包含了许多冗余信息或者十分稀疏或者计算量大，拿原始数据来训练是可行的，但是往往直接训练是低效的。所以特征提取往往是必要的。 特征提取主要是为了解决下面三个问题： （1）原始数据特征中的强相关性造成的冗余信息。（2）原始数据十分稀疏。（3）原始数据维度巨大。 特征提取的对象是原始数据（raw data），它的目的是自动地构建新的特征，将原始特征转换为一组具有明显物理意义（Gabor、几何特征[角点、不变量]、纹理[LBP HOG]）或者统计意义或核的特征。比如通过变换特征取值来减少原始数据中某个特征的取值个数等。对于表格数据，你可以在你设计的特征矩阵上使用主要成分分析来进行特征提取从而创建新的特征。对于图像数据，可能还包括了线或边缘检测。 常见的一些特征提取的方法： PCA主成分分析 LDA线性判别分析 ICA独立成分分析 特征选择特征选择目的是从特征集合中挑选一组最具统计意义的特征子集，从而达到降维的效果。特征选择是剔除不相关或者冗余的特征，减少有效特征的个数，减少模型训练的时间，提高模型的精确度。特征提取通过特征转换实现降维，特征选择则是依靠统计学方法或者于机器学习模型本身的特征选择（排序）功能实现降维。特征选择是个重复迭代的过程，有时可能自己认为特征选择做的很好，但实际中模型训练并不太好，所以每次特征选择都要使用模型去验证，最终目的是为了获得能训练出好的模型的数据，提升模型的性能。 特征选择过程一般包括产生过程，评价函数，停止准则，验证过程，这4个部分。如下图所示： (1) 产生过程( Generation Procedure )：产生过程是搜索特征子集的过程，负责为评价函数提供特征子集。(2) 评价函数( Evaluation Function )：评价函数是评价一个特征子集好坏程度的一个准则。(3) 停止准则( Stopping Criterion )：停止准则是与评价函数相关的，一般是一个阈值，当评价函数值达到这个阈值后就可停止搜索。(4) 验证过程( Validation Procedure ) ：在验证数据集上验证选出来的特征子集的有效性。 通常来说，从两个方面考虑来选择特征： 特征是否发散：如果一个特征不发散，例如方差接近于0，也就是说样本在这个特征上基本上没有差异，这个特征对于样本的区分并没有什么用。 特征与目标的相关性：这点比较显见，与目标相关性高的特征，应当优选选择。 根据特征选择的形式又可以将特征选择方法分为3种： Filter：过滤法，侧重于单个特征，按照发散性或者相关性对各个特征进行评分，设定阈值或者待选择阈值的个数，选择特征。 Wrapper：包装法，侧重于特征子集，根据目标函数（通常是预测效果评分），每次选择若干特征，或者排除若干特征。 Embedded：嵌入法，先使用某些机器学习的算法和模型进行训练，得到各个特征的权值系数，根据系数从大到小选择特征。类似于Filter方法，但是是通过训练来确定特征的优劣。 Filter过滤法一般使用评价准则来选择特征，从训练数据中选择全部特征向量空间，并在此空间内进行过滤、搜索，得到在阈值范围内的特征，确定最后的特征子集，放入机器学习算法中进行建模。 评价标准函数分为四类：距离度量、信息度量、依赖性度量和一致性度量。与特定的学习算法无关，所以具有良好的通用性。常用的评价标准有：方差、相关系数、卡方检验、互信息和最大信息系数。 ①方差 方差即衡量随机变量和其数学期望之间的偏离程度，其公式如下：$$σ^2=∑\frac{(X−μ)^2}{N}$$其中$\sigma^2$为总样本方差，$X$为变量，$\mu$为总样本均值，$N$为总样本数量 在特征选择中，可以默认去除方差没有达到定制标准的特征。因为如果方差很小，证明此维特征的差异性很小，则对最后结果的区分性也不是很大。 ②相关系数 Pearson相关系数衡量线性相关、Spearman相关系数衡量曲线相关、Kendall相关系数衡量两个变量观测排序的一致性。对于相关和不相关，在阈值设定上是有非常大的主观性的。Pearson相关系数的值介于-1到1之间，1 表示变量完全正相关，0 表示无关，-1 表示完全负相关。计算公式：$$r = \frac{1}{n-1}\sum_{i=1}^{n}{(\frac{X_i-\bar{X}}{S_X})(\frac{Y_i-\bar{Y}}{S_Y})}$$其中$\bar{X},\bar{Y}$为样本$X,Y$的平均值，$S_X,S_Y$为样本$X,Y$的标准差 注意：皮尔逊相关系数只对线性的特征敏感，如果关系是非线性的，即便是两个变量有很强的一一对应关系，pearson相关系数也有可能接近0。这种情况用spearman秩相关系数则能很好的表示出这种非线性的相关性。 ③卡方检验 卡方检验是检验定性自变量和定性因变量的相关性。在检验时，先做一个假设，假设两个变量是独立的；然后根据此假设计算独立时应该的理论值；计算实际值与理论值之间的差异，从而推翻假设或者服从假设。当应用在特征选择中，不关心具体的值，所以也就不存在推翻不推翻原假设，只关心大小，然后排序。$$\chi^2 = \sum\frac{(A-E)^2}{E}$$④互信息和最大信息系数 互信息表示随机变量中包含另个一随机变量的信息量，例如两个随机变量（X,Y），互信息是联合分布与乘积分布的相对熵：$$I(X，Y)=\sum p(x,y)\log(\frac{p(x,y)}{p(x)p(y)})$$ Wrapper此类方法是以分类器的目标函数，即利用学习算法的性能来评价特征子集的优劣。其实可以理解为以最终模型结果驱动来选择特征子集，这里也用到了在搜索中的分类方法，通过不同的搜索方法，选择若干候选特征子集，放入模型进行实验，多次实验选择使得模型得到较优结果的特征集合作为最终的特征子集。所以，对于一个待评价的特征子集，这种方法需要训练一个分类器，根据分类器的性能对该特征子集进行评价，从而进行特征选择和特征排除，最终选择特征子集，然后使用此分类器和特征子集进行建模。 Wrapper方法比Filter方法慢，但是此类方法得到的特征子集性能通常更好，但是通用性不强，改变学习算法时，需要针对特定的学习算法按照相应的指标重新选择特征子集，而且要重新训练和测试，所以对于这类方法通常计算复杂度挺高。其实每选择一次特征子集，就相当于进行了从头到尾的一次实验过程，个人认为这种是结果驱动的选择，换了训练的数据集都可能导致之前选择的特征子集失效。 Embedded特征选择本身是作为学习算法的一部分，是一种集成的方法，先使用某种学习算法进行训练，然后得到各个特征的权值系数，根据系数的大小对特征进行选择。类似于Filter方法，但是要经过模型训练才能得到相应的特征权重值。例如决策树算法（ID3、C4.5、C5、CART）使用了信息增益、信息增益比、Gini系数等指标，在每一层树增长的过程中，都需要进行特征选择。线性回归算法中，通过训练得到每个特征值的权重，可以根据权重选择特征，重新训练。L1范数正则化，通过在成本或者损失函数中添加L1范数，是的学习的结果满足稀疏化，从而得到适合的特征。这里要注意的是加入L1范数的惩罚项后，没有选择的特征并不是代表不重要，所以一般结合L2范数来优化处理。若一个特征在L1中的权值为1，选择在L2中权值差别不大且在L1中权值为0的特征构成同类集合，将这一集合中的特征平分L1中的权值，故需要构建一个新的逻辑回归模型。 在求解的过程中，我们往往要在平方误差项与正则化项之间折中，找出在平方误差等值线和正则化项等值线相交处。从下图中可以看出，采用L1范数的时候，与平方误差等值线的相交处经常出现在坐标轴上，也就是说得到的一些权重值(ω)为0，所以，使用L1范数的时候，我们能得到更稀疏的解[9]。Tibshirani在1996年提出的LASSO(Least Absolute Shrinkage and Selection Operator)回归就是使用L1范数。 局部加权回归模型（LOESS），对于区域样本使用多项式回归（Cleveland W1988）。这类局部回归有极强的适应性，可以有效得到平滑的回归趋势。 Conclusion绕了这么多，下面对几个专用名字做一个总结： 特征工程：利用数据领域的相关知识来创建能够使机器学习算法达到最佳性能的特征的过程。 特征构建：是原始数据中人工的构建新的特征。 特征提取：自动地构建新的特征，将原始特征转换为一组具有明显物理意义或者统计意义或核的特征。 特征选择：从特征集合中挑选一组最具统计意义的特征子集，从而达到降维的效果 特征工程是一个超集，它包括特征提取、特征构建和特征选择这三个子模块。在实践当中，每一个子模块都非常重要，忽略不得。根据经验，可以将这三个子模块的重要性进行了一个排名，即：特征构建&gt;特征提取&gt;特征选择。 事实上，真的是这样，如果特征构建做的不好，那么它会直接影响特征提取，进而影响了特征选择，最终影响模型的性能。 参考机器学习之特征工程 https://www.cnblogs.com/wxquare/p/5484636.html 细说特征工程 https://blog.csdn.net/m0_38024592/article/details/80836217 特征工程的概述 https://www.cnblogs.com/datasnail/p/9617480.html]]></content>
      <categories>
        <category>机器学习</category>
        <category>基础知识</category>
      </categories>
      <tags>
        <tag>机器学习</tag>
        <tag>特征工程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[机器学习项目完整流程]]></title>
    <url>%2F2019%2F03%2F22%2FMLfirst%2F</url>
    <content type="text"><![CDATA[机器学习项目工作流程作为一个刚刚接触Machine learning的小菜鸟来说，一开始并不是噼里啪啦的直接敲代码，机器学习的数据训练过程往往会耗费大量时间。一个很好的工作流程能帮助我们更好地使用机器学习工具来处理实际问题。 1.抽象为数学问题理解实际需要处理的问题是机器学习的第一步，机器学习中的特征工程和模型训练都需要耗费大量的时间，深入理解要处理的问题，从整体框架上构思，能够让我们避免走很多弯路。理解问题，主要包括明确可以获得的数据，以及我们的目标是什么。 机器学习的目标通常可以分为回归、分类、聚类。如果都不是，我们则需要考虑把它转换成机器学习问题。 2.获取数据获取数据主要包括获取原始数据以及经过特征工程后提取的训练数据、测试数据。”数据决定机器学习结果的上限，而算法只是尽可能的逼近这个上限“，可见数据对于机器学习的重要性。 总的来说，数据要具有“代表性”，否则数据会存在过拟合(overfitting)。对于分类问题，数据偏斜不能过于严重，不同类别的数据不要有数个数量级的差距。不仅如此，还要对数据的量级有一个评估，有多少的样本，有多少个特征，从中可以估算出对内存的消耗程度，判断训练过程中内存是否能够放得下。 如果数据量太大可以考虑减少训练样本、改进算法或者一些降维的方法。如果数据量实在太大，导致前面一些方法都不能有所改进，就只能考虑分布式了。 3.特征工程良好的数据要是能够提取出良好的特征才能真正发挥作用。 特征工程是一个非常能体现机器学习者功底的过程。特征工程包括从原始数据中特征构建、特征提取、特征选择。深入理解实际业务场景下的问题，丰富的机器学习经验能帮助我们更好的处理特征工程。特征工程做得好，往往能够使得算法的效果和性能得到显著的提升，有时能使简单的模型的效果比复杂的模型效果好。 数据预处理、数据清洗是很关键的步骤，往往能够使得算法的效果和性能得到显著提高。归一化、离散化、因子化、缺失值处理、去除共线性等，数据挖掘过程中很多时间就花在它们上面。这些工作简单可复制，收益稳定可预期，是机器学习的基础必备步骤。 筛选出显著特征、摒弃非显著特征，需要机器学习工程师反复理解业务。这对很多结果有决定性的影响。特征选择需要运用特征有效性分析的相关技术，如相关系数、卡方检验、平均互信息、条件熵、后验概率、逻辑回归权重等方法。 4.模型训练、诊断、调优现在有很多的机器学习算法的工具包，例如sklearn，使用非常方便，真正考验水平的是根据对算法的理解调节（超）参数，使模型达到最优。 过拟合、欠拟合的模型状态判断是模型诊断中至关重要的一步。常见的方法如：交叉验证，绘制学习曲线等。过拟合的基本调优思路是增加训练的数据量，降低模型复杂度。欠拟合的基本调优思路是提高特征数量和质量，增加模型复杂度。 诊断后的模型需要进行进一步调优，调优后的新模型需要重新诊断，这是一个反复迭代不断逼近的过程，需要不断的尝试，进而达到最优的状态。 5.模型验证、误差分析模型验证和误差分析也是机器学习中非常重要的一步。 通过测试数据，验证模型的有效性，通过观察误差样本，分析误差产生的原因（是参数的问题还是算法选择的问题，是特征的问题还是数据本身的问题 …），往往能使得我们找到提升算法性能的突破点。 误差分析主要是分析出误差来源于算法 、特征 、数据。 6.模型融合一般来说实际中，成熟的机器算法也就那么一些。工程上，提升算法的准确度主要方法是模型的前端（特征工程、清洗、预处理、采样）和后端的模型融合。因为他们比较标准可复制，效果比较稳定。而直接调参的工作不会很多，毕竟大量数据训练起来太慢了，而且效果难以保证。 模型融合的方法，主要包括一人一票的统一融合，线性融合和堆融合。 在机器学习中模型融合非常常见，基本都能使得效果有一定的提升，而且效果很好。 7.上线运行这一部分内容主要跟工程实现的相关性比较大。工程上是结果导向，模型在线上运行的效果直接决定模型的成败。不单纯包括其准确程度、误差等情况，还包括其运行的速度(时间复杂度)、资源消耗程度（空间复杂度）、稳定性是否可接受。 这些工作流程主要是工程实践上总结出的一些经验，并不是每个项目都包含完整的一个流程。这里的部分只是一个指导性的说明，只有大家自己多实践，多积累项目经验，才会有自己更深刻的认识。 参考机器学习项目流程 http://www.cnblogs.com/wxquare/p/5484690.html 一个完整机器学习项目流程总结https://www.jianshu.com/p/ecb89148ed64 完整机器学习项目的工作流程https://ask.julyedu.com/question/7013]]></content>
      <categories>
        <category>机器学习</category>
        <category>基础知识</category>
      </categories>
      <tags>
        <tag>机器学习</tag>
        <tag>项目流程</tag>
      </tags>
  </entry>
</search>
